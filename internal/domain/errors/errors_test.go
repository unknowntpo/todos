package errors

import (
	"database/sql"
	"fmt"
	"os"
	"testing"

	"github.com/pkg/errors"
	"github.com/stretchr/testify/assert"
)

func inner() error {
	const op Op = "inner operation"
	// same as doing errors.New("something goes wrong") and wrap it with E()
	//return errors.New("something goes wrong")
	return E(op, New("something goes wrong"))
}

func middle() error {
	const op Op = "middle operation"
	err := inner()
	if err != nil {
		return E(op, err)
	}
	return nil
}

func outer() error {
	const op Op = "outer operation"
	const email UserEmail = "alice@example.com"
	err := middle()
	if err != nil {
		return E(email, op, err)
	}
	return nil
}

func TestMsgFormat(t *testing.T) {
	if os.Getenv("TEST_UNIT") != "1" {
		t.Skip("skipping unit tests")
	}

	var counter int = 3
	msg := Msg("current counter value: %d").Format(counter)
	assert.Equal(t, "current counter value: 3", msg.String(), "formatted output should be equal")
}

// test building an error
// table-driven test
func TestE(t *testing.T) {
	if os.Getenv("TEST_UNIT") != "1" {
		t.Skip("skipping unit tests")
	}

	t.Run("build a KindRecordNotFound error", func(t *testing.T) {
		// define operation
		const op Op = "taskRepo.GetByID"

		// define fake user email
		userEmail := UserEmail("alice@example.com")
		// define error kind to ErrNotFound
		// assume that we performed an sql query to task database and got sql.ErrNoRows error.
		errFromDB := sql.ErrNoRows

		err := E(op, KindRecordNotFound, userEmail, errFromDB)
		assert.Equal(t, "alice@example.com: taskRepo.GetByID: record not found: sql: no rows in result set", err.Error())
	})
	t.Run("build a error with error message only", func(t *testing.T) {
		err := E(New("some error message"))

		assert.Equal(t, "some error message", err.Error())
	})
	t.Run("build a error with op and Error.Msg", func(t *testing.T) {
		const op Op = "Counter.Get"
		counter := 3
		err := E(op, Msg("current counter value: %d").Format(counter), New("some error message"))

		assert.Equal(t, "Counter.Get: current counter value: 3: some error message", err.Error())
	})

	t.Run("nested error with verb is %s", func(t *testing.T) {
		err := outer()
		want := "alice@example.com: outer operation: middle operation: inner operation: something goes wrong"
		assert.Equal(t, want, fmt.Sprintf("%s", err))
	})
	// TODO: Should we test stacktrace message ?
	t.Run("test if error generated by .E is stackTracer", func(t *testing.T) {
		const op Op = "TestE"
		err := E(op, New("test stacktracer"))

		type stackTracer interface {
			StackTrace() errors.StackTrace
		}
		_, ok := err.(stackTracer)
		if !ok {
			t.Fatalf("Error has type %T, and it's not a stackTracer.", err)
		}
	})

}

func TestUnwrap(t *testing.T) {
	if os.Getenv("TEST_UNIT") != "1" {
		t.Skip("skipping unit tests")
	}

	t.Run("errors.Is", func(t *testing.T) {
		// build nested error
		cause := sql.ErrNoRows
		err := E(Op("repo.Get"), cause)

		// use errors.Is to check the cause is what we want.
		if !errors.Is(err, sql.ErrNoRows) {
			t.Errorf("expect error is %v, but it's not.", cause)
		}
	})
	t.Run("errors.As", func(t *testing.T) {
		// TODO: Test errors.As
	})
}

func TestError(t *testing.T) {
	if os.Getenv("TEST_UNIT") != "1" {
		t.Skip("skipping unit tests")
	}

	t.Run("test duplicated error username and Kind", func(t *testing.T) {

	})
}

func TestKindIs(t *testing.T) {
	if os.Getenv("TEST_UNIT") != "1" {
		t.Skip("skipping unit tests")
	}

	t.Run("Success", func(t *testing.T) {
		// declare err which is *Error
		err := E(KindInternal)
		// call KindIs()
		isInternal := KindIs(err, KindInternal)
		assert.True(t, isInternal, "kind of error should be KindInternal")
	})
	t.Run("Panic", func(t *testing.T) {
		defer func() {
			if r := recover(); r != nil {
				assert.Equal(t, "want err has the type *Error, got *errors.errorString", r)
			}
		}()

		// call KindIs with error which does not have type *Error.
		_ = KindIs(sql.ErrNoRows, KindInternal)
	})
}

func TestKindInherit(t *testing.T) {
	if os.Getenv("TEST_UNIT") != "1" {
		t.Skip("skipping unit tests")
	}

	t.Run("Outer error doesn't have kind specified", func(t *testing.T) {
		inner := E(KindFailedValidation, errors.New("something goes wrong"))
		outer := E(inner)
		assert.True(t, KindIs(outer, KindFailedValidation), "the outer error with no kind specified should inherit inner error's kind")
	})
	t.Run("Outer error has kind specified", func(t *testing.T) {
		inner := E(KindFailedValidation, errors.New("something goes wrong"))
		outer := E(KindInternal, inner)
		assert.True(t, KindIs(outer, KindInternal), "the outer error with no kind specified should inherit inner error's kind")
	})
}
